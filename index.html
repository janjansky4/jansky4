<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pac-Man</title>
  <style>
    body {
      background: black;
      color: white;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
    }

    #hud {
      margin: 10px;
      font-size: 18px;
    }

    canvas {
      background: #000;
      border: 2px solid #222;
    }
  </style>
</head>
<body>
  <div id="hud">
    ‚ù§Ô∏è ≈Ωivoty: <span id="lives">3</span> &nbsp;&nbsp; ‚≠ê Sk√≥re: <span id="score">0</span>
  </div>

  <canvas id="game" width="448" height="496"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const scoreEl = document.getElementById("score");
    const livesEl = document.getElementById("lives");

    const tileSize = 16;
    const map = [
      "############################",
      "#............##............#",
      "#.####.#####.##.#####.####.#",
      "#o####.#####.##.#####.####o#",
      "#.####.#####.##.#####.####.#",
      "#..........................#",
      "#.####.##.########.##.####.#",
      "#.####.##.########.##.####.#",
      "#......##....##....##......#",
      "######.##### ## #####.######",
      "     #.##### ## #####.#     ",
      "     #.##          ##.#     ",
      "     #.## ###--### ##.#     ",
      "######.## #      # ##.######",
      "      .   #      #   .      ",
      "######.## #      # ##.######",
      "     #.## ######## ##.#     ",
      "     #.##          ##.#     ",
      "     #.## ######## ##.#     ",
      "######.## ######## ##.######",
      "#............##............#",
      "#.####.#####.##.#####.####.#",
      "#o..##................##..o#",
      "###.##.##.########.##.##.###",
      "#......##....##....##......#",
      "#.##########.##.##########.#",
      "#..........................#",
      "############################"
    ];

    const pacman = {
      x: 14 * tileSize,
      y: 23 * tileSize,
      dx: 0,
      dy: 0,
      speed: 2,
      mouth: 0,
      mouthDir: 1
    };

    let score = 0;
    let lives = 3;

    const ghosts = [
      { x: 13 * tileSize, y: 11 * tileSize, color: "red", dx: 2, dy: 0 },
      { x: 14 * tileSize, y: 11 * tileSize, color: "pink", dx: -2, dy: 0 },
      { x: 15 * tileSize, y: 11 * tileSize, color: "cyan", dx: 0, dy: 2 },
      { x: 16 * tileSize, y: 11 * tileSize, color: "orange", dx: 0, dy: -2 },
    ];

    document.addEventListener("keydown", e => {
      if (e.key === "ArrowUp") { pacman.dx = 0; pacman.dy = -pacman.speed; }
      if (e.key === "ArrowDown") { pacman.dx = 0; pacman.dy = pacman.speed; }
      if (e.key === "ArrowLeft") { pacman.dx = -pacman.speed; pacman.dy = 0; }
      if (e.key === "ArrowRight") { pacman.dx = pacman.speed; pacman.dy = 0; }
    });

    function drawMap() {
      for (let y = 0; y < map.length; y++) {
        for (let x = 0; x < map[y].length; x++) {
          const tile = map[y][x];
          if (tile === "#") {
            ctx.fillStyle = "#1919A6";
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
          } else if (tile === ".") {
            ctx.fillStyle = "yellow";
            ctx.beginPath();
            ctx.arc(x * tileSize + 8, y * tileSize + 8, 2, 0, Math.PI * 2);
            ctx.fill();
          } else if (tile === "o") {
            ctx.fillStyle = "yellow";
            ctx.beginPath();
            ctx.arc(x * tileSize + 8, y * tileSize + 8, 4, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
    }

    function drawPacman() {
      pacman.mouth += pacman.mouthDir * 0.2;
      if (pacman.mouth > 1 || pacman.mouth < 0) pacman.mouthDir *= -1;

      let angle = Math.atan2(pacman.dy, pacman.dx);
      if (isNaN(angle)) angle = 0;

      ctx.fillStyle = "yellow";
      ctx.beginPath();
      ctx.moveTo(pacman.x + 8, pacman.y + 8);
      ctx.arc(
        pacman.x + 8,
        pacman.y + 8,
        8,
        angle + pacman.mouth * 0.5,
        angle + Math.PI * 2 - pacman.mouth * 0.5
      );
      ctx.closePath();
      ctx.fill();
    }

    function moveEntity(entity) {
      const newX = entity.x + entity.dx;
      const newY = entity.y + entity.dy;
      const gridX = Math.floor(newX / tileSize);
      const gridY = Math.floor(newY / tileSize);
      if (map[gridY] && map[gridY][gridX] !== "#") {
        entity.x = newX;
        entity.y = newY;
      } else {
        // zmƒõna smƒõru p≈ôi n√°razu
        const dirs = [
          { dx: 2, dy: 0 },
          { dx: -2, dy: 0 },
          { dx: 0, dy: 2 },
          { dx: 0, dy: -2 }
        ];
        const randomDir = dirs[Math.floor(Math.random() * dirs.length)];
        entity.dx = randomDir.dx;
        entity.dy = randomDir.dy;
      }
    }

    function updatePacman() {
      const newX = pacman.x + pacman.dx;
      const newY = pacman.y + pacman.dy;
      const gridX = Math.floor(newX / tileSize);
      const gridY = Math.floor(newY / tileSize);
      if (map[gridY] && map[gridY][gridX] !== "#") {
        pacman.x = newX;
        pacman.y = newY;

        const char = map[gridY][gridX];
        if (char === "." || char === "o") {
          score += char === "." ? 10 : 50;
          map[gridY] = map[gridY].substring(0, gridX) + " " + map[gridY].substring(gridX + 1);
          scoreEl.textContent = score;
        }
      }
    }

    function drawGhosts() {
      ghosts.forEach(g => {
        ctx.fillStyle = g.color;
        ctx.beginPath();
        ctx.arc(g.x + 8, g.y + 8, 8, Math.PI, 0);
        ctx.lineTo(g.x + 16, g.y + 16);
        ctx.lineTo(g.x, g.y + 16);
        ctx.closePath();
        ctx.fill();
      });
    }

    function checkCollisions() {
      for (const g of ghosts) {
        const dist = Math.hypot(g.x - pacman.x, g.y - pacman.y);
        if (dist < 12) {
          lives--;
          livesEl.textContent = lives;
          if (lives <= 0) {
            alert("üíÄ Konec hry! Tv√© sk√≥re: " + score);
            document.location.reload();
          } else {
            resetPositions();
          }
        }
      }
    }

    function resetPositions() {
      pacman.x = 14 * tileSize;
      pacman.y = 23 * tileSize;
      pacman.dx = 0;
      pacman.dy = 0;
      ghosts.forEach((g, i) => {
        g.x = (13 + i) * tileSize;
        g.y = 11 * tileSize;
      });
    }

    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMap();
      updatePacman();
      drawPacman();
      ghosts.forEach(moveEntity);
      drawGhosts();
      checkCollisions();
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>

